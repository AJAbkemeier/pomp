% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/spect_match.R
\docType{methods}
\name{spect.match}
\alias{spect.match}
\alias{spect.match.objfun}
\alias{spect.match.objfun,missing-method}
\alias{spect.match.objfun,ANY-method}
\alias{spect.match.objfun-data.frame}
\alias{spect.match.objfun,data.frame-method}
\alias{spect.match.objfun-pomp}
\alias{spect.match.objfun,pomp-method}
\alias{spect.match.objfun-spectd_pomp}
\alias{spect.match.objfun,spectd_pomp-method}
\alias{spect.match.objfun-spect_match_objfun}
\alias{spect.match.objfun,spect_match_objfun-method}
\title{Spectrum matching}
\usage{
\S4method{spect.match.objfun}{data.frame}(data, rinit, rprocess, rmeasure,
  params, est = character(0), vars, nsim, seed = NULL, kernel.width,
  transform.data, detrend, weights = 1, fail.value = NA,
  transform = FALSE, ..., verbose = getOption("verbose", FALSE))

\S4method{spect.match.objfun}{pomp}(data, est = character(0), vars, nsim,
  seed = NULL, kernel.width, transform.data, detrend, weights = 1,
  fail.value = NA, transform = FALSE, ...,
  verbose = getOption("verbose", FALSE))

\S4method{spect.match.objfun}{spectd_pomp}(data, est, vars, nsim,
  seed = NULL, kernel.width, transform.data, detrend, ...,
  verbose = getOption("verbose", FALSE))

\S4method{spect.match.objfun}{spect_match_objfun}(data, ...)
}
\arguments{
\item{data}{either a data frame holding the time series data, or an object of class \sQuote{pomp}, i.e., the output of one of \pkg{pomp}'s methods.}

\item{rinit}{simulator of the initial-state distribution.
This can be furnished either as a C snippet, an \R function, or the name of a pre-compiled native routine available in a dynamically loaded library.
For more information on specifying \code{rinit}, see \link[=rinit_spec]{here}.}

\item{rprocess}{simulator of the latent state process, specified either as a C snippet, an \R function, or the name of a pre-compiled native routine available in a dynamically loaded library.
For more information on specifying \code{rprocess}, see \link[=rprocess_spec]{here}.}

\item{rmeasure}{simulator of the measurement model, specified either as a C snippet, an \R function, or the name of a pre-compiled native routine available in a dynamically loaded library.
For more information on specifying \code{rmeasure}, see \link[=rmeasure_spec]{here}.}

\item{params}{optional; named numeric vector of parameters.  This will be
coerced internally to storage mode \code{double}.}

\item{est}{character vector; the names of parameters to be estimated.}

\item{vars}{optional; names of observed variables for which the power spectrum will be computed.
By default, the spectrum will be computed for all observables.}

\item{nsim}{the number of model simulations to be computed.}

\item{seed}{optional integer;
if non-\code{NULL}, the random number generator will be initialized with this seed for simulations.
See \code{\link[=simulate-pomp]{simulate}}.}

\item{kernel.width}{width parameter for the smoothing kernel used for
calculating the estimate of the spectrum.}

\item{transform.data}{function; this transformation will be applied to the
observables prior to estimation of the spectrum, and prior to any
detrending.}

\item{detrend}{de-trending operation to perform.  Options include no
detrending, and subtraction of constant, linear, and quadratic trends from
the data.  Detrending is applied to each data series and to each model
simulation independently.}

\item{weights}{optional numeric or function.
The mismatch between model and data is measured by a weighted average of mismatch at each frequency.
By default, all frequencies are weighted equally.
\code{weights} can be specified either as a vector (which must have length equal to the number of frequencies) or as a function of frequency.
If the latter, \code{weights(freq)} must return a nonnegative weight for each frequency.}

\item{fail.value}{optional numeric scalar;
if non-\code{NA}, this value is substituted for non-finite values of the objective function.
It should be a large number (i.e., bigger than any legitimate values the objective function is likely to take).}

\item{transform}{logical;
if \code{TRUE}, optimization is to be performed on the transformed scale.}

\item{...}{additional arguments supply new or modify existing model characteristics or components.}

\item{verbose}{if \code{TRUE}, diagnostic messages will be printed to the console}
}
\value{
\code{spect.match.objfun} constructs a stateful objective function for spectrum matching.
Specifically, \code{spect.match.objfun} returns an object of class \sQuote{spect_match_objfun}, which is a function suitable for use in an \code{\link{optim}}-like optimizer.
In particular, this function takes a single numeric-vector argument that is assumed to contain the parameters named in \code{est}, in that order.
When called, it will return the (optionally weighted) \eqn{L^2}{L2} distance between the data spectrum and simulated spectra.
It is a stateful function:
Each time it is called, it will remember the values of the parameters and the discrepancy measure.
}
\description{
Estimation of parameters by matching power spectra
}
\details{
In spectrum matching, one attempts to minimize the discrepancy between a \acronym{POMP} model's predictions and data, as measured in the frequency domain by the power spectrum.

\code{spect.match.objfun} constructs an objective function that measures the discrepancy.
It can be passed to any one of a variety of numerical optimization routines, which will adjust model parameters to minimize the discrepancies between the power spectrum of model simulations and that of the data.
}
\section{Important Note}{

Since \pkg{pomp} cannot guarantee that the \emph{final} call an optimizer makes to the function is a call \emph{at} the optimum, it cannot guarantee that the parameters stored in the function are the optimal ones.
One should check that the parameters agree with those that are returned by the optimizer.
The best practice is to call \code{\link[=spect,spect_match_objfun-method]{spect}} on the objective function after the optimization has been performed, thus obtaining a \sQuote{spectd_pomp} object containing the (putative) optimal parameters.
}

\seealso{
\code{\link{trajectory}}, \code{\link{optim}},
\code{\link[subplex]{subplex}}, \code{\link[nloptr]{nloptr}}
}
