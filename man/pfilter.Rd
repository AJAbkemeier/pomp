% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pfilter.R
\docType{methods}
\name{pfilter}
\alias{pfilter}
\alias{pfilter,ANY-method}
\alias{pfilter,missing-method}
\alias{pfilter-pomp}
\alias{pfilter,pomp-method}
\alias{pfilter-pfilterd_pomp}
\alias{pfilter,pfilterd_pomp-method}
\title{Particle filter}
\usage{
\S4method{pfilter}{pomp}(object, params, Np, tol = 1e-17,
  max.fail = Inf, pred.mean = FALSE, pred.var = FALSE,
  filter.mean = FALSE, filter.traj = FALSE, save.states = FALSE,
  save.params = FALSE, verbose = getOption("verbose"), ...)

\S4method{pfilter}{pfilterd_pomp}(object, params, Np, tol, ...)
}
\arguments{
\item{object}{An object of class \sQuote{pomp} or inheriting class \dQuote{pomp}.}

\item{params}{optional named numeric vector containing the parameters at which the filtering should be performed.
By default, \code{params = coef(object)}.}

\item{Np}{the number of particles to use.
This may be specified as a single positive integer, in which case the same number of particles will be used at each timestep.
Alternatively, if one wishes the number of particles to vary across timesteps, one may specify \code{Np} either as a vector of positive integers of length \preformatted{length(time(object,t0=TRUE))} or as a function taking a positive integer argument.
In the latter case, \code{Np(k)} must be a single positive integer, representing the number of particles to be used at the \code{k}-th timestep:
\code{Np(0)} is the number of particles to use going from \code{timezero(object)} to \code{time(object)[1]},
\code{Np(1)}, from \code{timezero(object)} to \code{time(object)[1]},
and so on,
while when \code{T=length(time(object,t0=TRUE))}, \code{Np(T)} is the number of particles to sample at the end of the time-series.
When \code{object} is of class \sQuote{mif}, this is by default the same number of particles used in the \code{mif} iterations.

One should omit \code{Np} if \code{params} is a matrix of parameters, with one column for each particle.  In this case, obviously, the number of particles is \code{ncol(params)}.}

\item{tol}{positive numeric scalar;
particles with likelihood less than \code{tol} are considered to be incompatible with the data.
See the section on \emph{Filtering Failures} below for more information.}

\item{max.fail}{integer; the maximum number of filtering failures allowed (see below).
If the number of filtering failures exceeds this number, execution will terminate with an error.
By default, \code{max.fail} is set to infinity, so no error can be triggered.}

\item{pred.mean}{logical; if \code{TRUE}, the prediction means are calculated for the state variables and parameters.}

\item{pred.var}{logical; if \code{TRUE}, the prediction variances are calculated for the state variables and parameters.}

\item{filter.mean}{logical; if \code{TRUE}, the filtering means are calculated for the state variables and parameters.}

\item{filter.traj}{logical; if \code{TRUE}, a filtered trajectory is returned for the state variables and parameters.}

\item{save.states, save.params}{logical.
If \code{save.states=TRUE}, the state-vector for each particle at each time is saved in the \code{saved.states} slot of the returned \sQuote{pfilterd_pomp} object.
If \code{save.params=TRUE}, the parameter-vector for each particle at each time is saved in the \code{saved.params} slot of the returned \sQuote{pfilterd_pomp} object.}

\item{verbose}{logical; if \code{TRUE}, progress information is reported as \code{pfilter} works.}

\item{\dots}{Additional arguments are passed to \code{\link{pomp}}, allowing one to supply new or modify existing model characteristics or components.}
}
\value{
An object of class \sQuote{pfilterd_pomp}, which extends class \sQuote{pomp}.
}
\description{
A plain vanilla sequential Monte Carlo (particle filter) algorithm.
Resampling is performed at each observation.
}
\section{Methods}{

\describe{
\item{logLik}{ the estimated log likelihood  }
\item{cond.logLik}{ the estimated conditional log likelihood }
\item{eff.sample.size}{ the (time-dependent) estimated effective sample size }
\item{pred.mean, pred.var}{ the mean and variance of the approximate prediction distribution }
\item{filter.mean}{ the mean of the filtering distribution }
}
}

\examples{

pompExample(gompertz)
pf <- pfilter(gompertz,Np=1000)	## use 1000 particles
plot(pf)
logLik(pf)
cond.logLik(pf)			## conditional log-likelihoods
eff.sample.size(pf)             ## effective sample size
logLik(pfilter(pf))      	## run it again with 1000 particles
## run it again with 2000 particles
pf <- pfilter(pf,Np=2000,filter.mean=TRUE)
fm <- filter.mean(pf)    	## extract the filtering means

}
\references{
M. S. Arulampalam, S. Maskell, N. Gordon, & T. Clapp.
A Tutorial on Particle Filters for Online Nonlinear, Non-Gaussian Bayesian Tracking.
IEEE Trans. Sig. Proc. 50:174--188, 2002.
}
\seealso{
\code{\link{mif2}}, \code{\link{pmcmc}}, \code{\link{bsmc2}}, and
the tutorials on the \href{https://kingaa.github.io/pomp}{package website}.

Other particle filter methods: \code{\link{cond.logLik}},
  \code{\link{eff.sample.size}}, \code{\link{filter.mean}},
  \code{\link{mif2}}, \code{\link{pmcmc}},
  \code{\link{pred.mean}}, \code{\link{pred.var}}
}
\author{
Aaron A. King
}
\concept{particle filter methods}
