setMethod(
  "pompLoad",
  signature=signature(object="pomp"),
  definition = function (object, ...) {
    pompLoad.internal(object,...)
  })

setMethod(
  "pompUnload",
  signature=signature(object="pomp"),
  definition = function (object, ...) {
    pompUnload.internal(object,...)
  })

pompLoad.internal <- function (object, ...,
  verbose = getOption("verbose", FALSE)) {
  for (lib in object@solibs) {
    if (!is.loaded("__pomp_load_stack_incr",PACKAGE=lib$name)) {
      dir <- srcDir(lib$dir,verbose=verbose)
      solib <- file.path(dir,paste0(lib$name,.Platform$dynlib.ext))
      if (file.exists(solib)) {
        dyn.load(solib)
      } else {
        pompCompile(fname=lib$name,direc=dir,src=lib$src,verbose=verbose)
        dyn.load(solib)
      }
      if (verbose) cat("loading",sQuote(solib),"\n")
    }
    .Call(load_stack_incr,lib$name)
  }
  invisible(NULL)
}

pompUnload.internal <- function (object, ...,
  verbose = getOption("verbose", FALSE)) {
  for (lib in object@solibs) {
    if (is.loaded("__pomp_load_stack_decr",PACKAGE=lib$name)) {
      st <- .Call(load_stack_decr,lib$name)
      if (st==0) {
        dir <- srcDir(lib$dir,verbose=verbose)
        solib <- file.path(dir,paste0(lib$name,.Platform$dynlib.ext))
        dyn.unload(solib)
        if (verbose) cat("unloading",sQuote(solib),"\n")
      }
    }
  }
  invisible(NULL)
}

## useful for prepending the 'lib' generated by 'hitch' to the 'solibs'
## slot of a 'pomp' object
setMethod(
  "solibs<-",
  signature=signature(object="pomp"),
  definition=function (object, ..., value) {
    if (!is.null(value)) {
      object@solibs <- c(list(value),object@solibs)
    }
    object
  }
)
